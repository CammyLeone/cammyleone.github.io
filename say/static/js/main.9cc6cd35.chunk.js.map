{"version":3,"sources":["../../src/ConnectAToy.js","../../src/useButtPlug.js","hooks/useSelfDismissing.js","LineWriter.js","hooks/useTimesOutIn.js","../../src/useVibration.js","App.js","serviceWorker.js","index.js","../external \"Buttplug\""],"names":["ConnectAToy","onNewDevice","useState","ready","useEffect","newClient","device","setDevice","setIsConnected","setClient","client","a","connector","console","start","useButtPlug","isReady","render","initiateConnection","setReady","useSelfDismissing","timeout","shown","setShown","setTimeout","bind","LineWriter","max","line","times","currentTimes","setCurrentTimes","text","updateText","isWrongShown","showWrong","isExpiredShown","showExpired","millis","mostRecent","setMostRecent","isExpired","setExpired","useRef","current","clearTimeout","Date","now","useTimesOutIn","resetExpired","level","startVibrate","stopVibrate","useVibration","d3","clamp","domain","range","scale","style","color","height","backgroundColor","htmlFor","slice","length","type","onChange","e","startsWith","target","value","App","onClick","Boolean","window","location","hostname","match","ReactDOM","StrictMode","document","getElementById","navigator","serviceWorker","then","registration","unregister","catch","error","message","module","exports","Buttplug"],"mappings":"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","file":"static/js/main.9cc6cd35.chunk.js","sourcesContent":["import { useState } from \"react\";\nimport useButtPlug from \"./useButtPlug\";\n\nexport default function ConnectAToy({ render, onNewDevice }) {\n  const [isReady, setReady] = useState(false);\n\n  useButtPlug(isReady, onNewDevice);\n\n  if (!isReady) return render({ initiateConnection: () => setReady(true) });\n  return null;\n}\n","import { useState, useEffect } from \"react\";\nimport { ButtplugClient, ButtplugEmbeddedClientConnector } from \"buttplug\";\n\nexport default function useButtPlug(ready, onNewDevice) {\n  const [client, setClient] = useState(null);\n  const [device, setDevice] = useState([]);\n  const [isConnected, setIsConnected] = useState(false);\n\n  useEffect(() => {\n    if (!ready || client) return;\n\n    const newClient = new ButtplugClient(\"Cammy\");\n    newClient.addListener(\"deviceadded\", (device) => {\n      setDevice(device);\n      setIsConnected(true);\n      onNewDevice(device);\n    });\n\n    setClient(newClient);\n  }, [ready, onNewDevice, client, device, isConnected]);\n\n  useEffect(() => {\n    if (!client || isConnected) return;\n\n    async function start() {\n      try {\n        const connector = new ButtplugEmbeddedClientConnector();\n        await client.Connect(connector);\n      } catch (e) {\n        console.log(e);\n        return;\n      }\n      await client.StartScanning();\n    }\n    start();\n  }, [client, isConnected]);\n\n  return { client, device, isConnected };\n}\n","import { useState, useEffect } from \"react\";\n\nexport default function useSelfDismissing(timeout) {\n  const [shown, setShown] = useState(false);\n  useEffect(() => {\n    if (shown) setTimeout(() => setShown(false), timeout);\n  }, [shown, timeout]);\n\n  return [shown, setShown.bind(true)];\n}\n","import React, { useState, useEffect } from \"react\";\nimport { useVibration } from \"react-buttplug\";\n\nimport * as d3 from \"./d3-bundle\";\nimport useSelfDismissing from \"./hooks/useSelfDismissing\";\nimport useTimesOutIn from \"./hooks/useTimesOutIn\";\n\nconst scale = (times) =>\n  d3.scaleLinear().clamp(true).domain([0, times]).range([0, 1]);\n\nconst color = (max) =>\n  d3.scaleSequential(d3.interpolatePlasma).domain([0, max]);\n\nfunction LineWriter({ device, line, times }) {\n  const [currentTimes, setCurrentTimes] = useState(0);\n  const [text, updateText] = useState(\"\");\n  const [isWrongShown, showWrong] = useSelfDismissing(1000);\n  const [isExpiredShown, showExpired] = useSelfDismissing(1000);\n  const [isExpired, resetExpired] = useTimesOutIn(3000);\n  useVibration(device, scale(times)(currentTimes));\n\n  useEffect(() => {\n    if (!isExpired) return;\n    setCurrentTimes(0);\n    updateText(\"\");\n    showExpired(true);\n    resetExpired();\n  }, [isExpired, showExpired, resetExpired]);\n\n  function onChange(text) {\n    resetExpired();\n\n    if (line === text) {\n      setCurrentTimes(currentTimes + 1);\n      updateText(\"\");\n    } else if (line.startsWith(text)) {\n      updateText(text);\n    } else {\n      setCurrentTimes(0);\n      updateText(\"\");\n      showWrong(true);\n    }\n  }\n\n  return (\n    <div\n      style={{\n        color: \"#FFF\",\n        height: \"100vh\",\n        backgroundColor: color(times)(currentTimes),\n      }}\n    >\n      <section>\n        <label htmlFor=\"line\">\n          <strong>{text}</strong>\n          <i>{line.slice(text.length)}</i>\n        </label>\n      </section>\n      <section>\n        <input\n          type=\"text\"\n          onChange={(e) => onChange(e.target.value)}\n          value={text}\n        />\n      </section>\n      <section>\n        {currentTimes} / {times}\n      </section>\n      {isWrongShown && <h2>WRONG</h2>}\n      {isExpiredShown && <h2>EXPIRED</h2>}\n    </div>\n  );\n}\n\nexport default LineWriter;\n","import { useRef, useState, useEffect } from \"react\";\n\nexport default function useTimesOutIn(millis) {\n  const [mostRecent, setMostRecent] = useState(null);\n  const [isExpired, setExpired] = useState(false);\n  const timeout = useRef(null);\n  useEffect(() => {\n    if (isExpired) return;\n\n    if (timeout.current) clearTimeout(timeout.current);\n    timeout.current = setTimeout(() => setExpired(true), millis);\n  }, [mostRecent, isExpired, millis]);\n\n  const resetExpired = () => {\n    setExpired(false);\n    setMostRecent(Date.now());\n  };\n  return [isExpired, resetExpired];\n}\n","import { useEffect } from \"react\";\n\nexport default function useVibrate(device, level) {\n  useEffect(() => {\n    if (!device) return;\n\n    async function startVibrate() {\n      console.log(\"startVibrate()\");\n      await device.SendVibrateCmd(level);\n      console.log(\"startVibrate() over\");\n    }\n\n    async function stopVibrate() {\n      console.log(\"stopVibrate()\");\n      await device.SendStopDeviceCmd();\n      console.log(\"stopVibrate() over\");\n    }\n\n    console.log(`vibrateEffect: ${level}`);\n    if (level > 0) {\n      startVibrate();\n    } else {\n      stopVibrate();\n    }\n  }, [device, level]);\n\n  return null;\n}\n","import React, { useState } from \"react\";\nimport { ConnectAToy } from \"react-buttplug\";\n\nimport LineWriter from \"./LineWriter\";\n\nfunction App() {\n  const [device, setDevice] = useState(null);\n\n  if (!device)\n    return (\n      <ConnectAToy\n        render={({ initiateConnection }) => (\n          <button onClick={initiateConnection}>Write some Lines</button>\n        )}\n        onNewDevice={setDevice}\n      />\n    );\n\n  return <LineWriter device={device} line=\"I like cock a lot\" times={10} />;\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","module.exports = Buttplug;"],"sourceRoot":""}